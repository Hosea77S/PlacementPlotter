#include "ctsParser.h"



void ctsParser::writeToSinksFile(const Placement* clkSinkNodes, std::string outFilename){
	
	std::cout << "Writing to .sinks file: " << outFilename << std::endl;
	std::ofstream fout;
	fout.open(outFilename);

	if (!fout)
		myAssert2 (0, "(E) Error opening output file: ",  outFilename );

	//fout << "#USC pl 1.0\n";
	//fout << "# Created\n";
	//fout << "# Platform\n\n";
	fout << "NumPins : " << (*clkSinkNodes).getSize() << "\n";
	fout << "\n" ;
	fout << "PerUnitResistance : 1\n";
	fout << "\n" ;
	fout << "PerUnitCapacitance : 1.000000e-25\n";
	fout << "\n" ;

//	Sink : 0 
//    Coordinate : 0 0 
//    Capacitive Load :  5.000000e-14 


	for (int i = 0; i < (*clkSinkNodes).getSize(); i++)
	{
		Point node = (*clkSinkNodes)[i];
		fout << "Sink : " << i << "\n";
		fout << "\tCoordinate : " << node.x << "\t" << node.y << "\n";
		//fout << "\tCapacitive Load :  5.000000e-14" << std::endl;
		fout << "\tCapacitive Load :  0.0" << std::endl;
		fout << "\tDownstream_Delay : 0.0" << std::endl;
		fout << std::endl;
	}
	fout.close();

	
}


void ctsParser::write2TopologyFile 
  (std::string outFilename, const std::vector<dbClkCell>& top)
{
  std::cout << "Writing to .top file: " << outFilename << std::endl;
  std::ofstream fout;
  fout.open(outFilename);
  
  if (!fout)
  	myAssert2 (0, "(E) Error opening output file: ",  outFilename );
  for (unsigned i=0; i < top.size(); i++)
  {
    //id:19  child:15 18 par:10
	auto cur = top.at(i);
	fout << "id:" << cur.getId() << " child:" << cur.getLeft()
	 << " " << cur.getRight() << " par:" << cur.getParent() << "\n"; 
  }
  fout.close();

  return;      	
}


void ctsParser::writeTopology2DotFile 
  (std::string outFilename, const std::vector<dbClkCell>& top)
{
  std::cout << "Writing to .graph file: " << outFilename << std::endl;
  std::ofstream fout;
  fout.open(outFilename);
  
  if (!fout)
  	myAssert2 (0, "(E) Error opening output file: ",  outFilename );
  fout << "digraph Topology {\n";
  fout << "node [fontname=\"Bookman Old Style\"];\n";
  
  for (unsigned i=0; i < top.size(); i++)
  {
    //0 -> 1
	auto cur = top.at(i);
	if (cur.getLeft()!=-1)
	  fout << cur.getId() << " -> " << cur.getLeft() << ";\n";
	if (cur.getRight()!=-1)
	  fout << cur.getId() << " -> " << cur.getRight() << ";\n";
    if (cur.isSinkNode())
	  fout << cur.getId() << "[label=\"" << cur.getId() << "(" <<
			cur.getOrigin().x << "," << cur.getOrigin().y << ")\""
			<< " color=blue];\n";
		
  }
  fout << " \n}";
  fout.close();

/*   try{
	std::string cmd = "dot -Tpng " + outFilename + " -o " + outFilename + ".png"  ;
	std::cout << " Caling cmd: " << cmd << "\n";
	system(cmd.c_str());		
	  
  } catch (...)
  {
	myWarn(0, "Can't call dot to draw the clock topology.\n");  
  } */
  
  return;      	
}


//Reads from .clock file (generated by BST) and returns a vector of merging segments
std::vector<dbClkCell*> 
	ctsParser::readFromClocksFile(std::string FileName){
	std::vector<dbClkCell*> clkVec;
	parseClocksFile(FileName, clkVec);
	
	std::cout << "\tRead successfully from " << FileName << std::endl;
	return clkVec;
}

//Parses .clock file (generated by BST) and returns a vector of merging segments
//Note, doesn't populate myCell instance of dbClkCell,
//That should be done by CTS class
void ctsParser::parseClocksFile 
	(std::string FileName, std::vector<dbClkCell*>& clkVec){
	
	//clkTree clt(this->chip, )
	const char *filename = FileName.c_str();
	std::ifstream fin;
    fin.open(filename);
    if (!fin)
	myAssert2 (0, "(E) Error opening input file: ", filename );

    std::cout << "\treading from file: " << filename << std::endl;

    /*read preambles*/
    std::string   comment;
    getline( fin,comment );
    do
    {
        getline(fin, comment);
    } while((comment.c_str())[0]=='#');

    int tot_nodes = 0;
    std::istringstream in1(comment);
    getline(in1, comment, ':');
    if(!in1)
    {
        getline(fin, comment,':');
        fin >> tot_nodes;
    }
    else
        in1 >> tot_nodes;
	
	myAssert ( tot_nodes > 0, "Can't find total number of clock nodes. Returning." );

	dbClkCell* temp = new dbClkCell( (int)tot_nodes/2 );
	std::vector<dbClkCell*> cv (tot_nodes, temp);
	
    std::string blah;
    while (getline(fin, blah))
    {
		//id:15  child:13 14 par:8 500.00 500.00
        std::istringstream in(blah);
        double  x, y;
		int left, right, parent, id;
        std::string  tem;
        in >> id >> left >> right >> parent >> x >> y;
		if (!in)
		   continue;
        in >> tem;
		
		myAssert3 ( id <= tot_nodes, id, "id is larger than total number of clock sinks. Returning.", tot_nodes)
		
		dbClkCell* curClkCell = new dbClkCell (id, left, right, parent, Point(x,y), NULL ); 
		cv[id] = curClkCell ;
		//std::cout << "id: " << id << " loc: " << curClkCell->getOrigin() << "\n";
    }
	clkVec  = cv;
	
	//cts engine generates a node for the clk source, but doesn't include that in the list of nodes, hence: tot_nodes-1
	myAssert3 ( tot_nodes   == int(clkVec.size()), tot_nodes,
		" tot_nodes doesn't have same size as clkVec ", clkVec.size() );
	
	//critical, do this
	std::sort ( clkVec.begin(), clkVec.end(), 
		CompareClkCellsByID() );
	
	//std::cout << clkVec << std::endl;
    fin.close();
	
	return;
}

